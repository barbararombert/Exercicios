<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <title>Mini Labirinto – Telemóvel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    body {
      margin: 0;
      background: #111;
      color: #fff;
      font-family: system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      overflow: hidden;
    }

    #info {
      padding: 10px;
      text-align: center;
      font-size: 14px;
    }

    #gameContainer {
      position: relative;
      width: 100%;
      max-width: 450px;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    canvas {
      background: #222;
      border: 2px solid #555;
      border-radius: 8px;
      width: 100%;     /* escala o canvas para caber no ecrã */
      height: auto;
    }

    #startBtn {
      margin: 8px 0;
      padding: 8px 16px;
      border-radius: 6px;
      border: none;
      background: #0a84ff;
      color: white;
      font-size: 14px;
      font-weight: 600;
    }

    #startBtn:active {
      opacity: 0.8;
    }

    #status {
      font-size: 14px;
      margin-bottom: 6px;
    }
  </style>
</head>
<body>
  <div id="info">
    <div id="status">Inclina o telemóvel para mover o jogador. Apanha as 3 moedas e vai até à porta!</div>
    <button id="startBtn">Ativar movimento do telemóvel</button>
  </div>

  <div id="gameContainer">
    <canvas id="game" width="400" height="600"></canvas>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const startBtn = document.getElementById("startBtn");

    // Jogador
    const player = {
      x: 40,
      y: 560,
      r: 10
    };

    // Tilt (inclinação do telemóvel)
    let tiltX = 0; // esquerda/direita (gamma)
    let tiltY = 0; // cima/baixo (beta)

    // Paredes do labirinto (retângulos)
    const walls = [
      // Bordas
      { x: 0,   y: 0,   w: 400, h: 10 },
      { x: 0,   y: 590, w: 400, h: 10 },
      { x: 0,   y: 0,   w: 10,  h: 600 },
      { x: 390, y: 0,   w: 10,  h: 600 },

      // Paredes internas (podes mudar à vontade)
      { x: 50,  y: 100, w: 300, h: 10 },
      { x: 50,  y: 100, w: 10,  h: 200 },
      { x: 90,  y: 290, w: 270, h: 10 },
      { x: 90,  y: 150, w: 10,  h: 150 },
      { x: 140, y: 150, w: 210, h: 10 },
      { x: 340, y: 150, w: 10,  h: 150 },
      { x: 140, y: 200, w: 10,  h: 240 },
      { x: 190, y: 200, w: 160, h: 10 },
      { x: 190, y: 200, w: 10,  h: 200 },
      { x: 230, y: 390, w: 170, h: 10 },
      { x: 50,  y: 390, w: 120, h: 10 },
      { x: 50,  y: 390, w: 10,  h: 130 },
      { x: 90,  y: 430, w: 260, h: 10 }
    ];

    // Moedas
    const coins = [
      { x: 80,  y: 70,  r: 8, collected: false },
      { x: 260, y: 260, r: 8, collected: false },
      { x: 120, y: 520, r: 8, collected: false }
    ];

    // Porta de saída (só ativa depois de 3 moedas)
    const exitDoor = {
      x: 330,
      y: 20,
      w: 40,
      h: 40,
      active: false
    };

    let lastTime = 0;
    let gameStarted = false;

    function resetGame() {
      player.x = 40;
      player.y = 560;
      coins.forEach(c => c.collected = false);
      exitDoor.active = false;
      statusEl.textContent = "Inclina o telemóvel para mover o jogador. Apanha as 3 moedas e vai até à porta!";
    }

    // Pedir permissão para usar o sensor em iOS / alguns browsers
    async function enableOrientation() {
      try {
        if (typeof DeviceOrientationEvent !== "undefined" &&
            typeof DeviceOrientationEvent.requestPermission === "function") {
          const response = await DeviceOrientationEvent.requestPermission();
          if (response === "granted") {
            window.addEventListener("deviceorientation", handleOrientation);
            statusEl.textContent = "Sensores ativados! Jogo em curso.";
            gameStarted = true;
          } else {
            statusEl.textContent = "Permissão negada. Não é possível usar o sensor de movimento.";
          }
        } else {
          // Android / outros
          window.addEventListener("deviceorientation", handleOrientation);
          statusEl.textContent = "Sensores ativados! Jogo em curso.";
          gameStarted = true;
        }
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Erro ao tentar aceder ao sensor de movimento.";
      }
    }

    function handleOrientation(event) {
      // gamma: esquerda/direita, beta: frente/trás
      tiltX = event.gamma || 0;
      tiltY = event.beta || 0;
    }

    startBtn.addEventListener("click", () => {
      enableOrientation();
    });

    // Colisão círculo-retângulo
    function circleRectCollision(px, py, pr, rect) {
      const closestX = Math.max(rect.x, Math.min(px, rect.x + rect.w));
      const closestY = Math.max(rect.y, Math.min(py, rect.y + rect.h));
      const dx = px - closestX;
      const dy = py - closestY;
      return (dx * dx + dy * dy) < (pr * pr);
    }

    // Update
    function update(dt) {
      if (!gameStarted) return;

      // Converter tilt em velocidade
      const maxSpeed = 4; // px por "frame"
      const vx = (tiltX / 45) * maxSpeed; // inclinação de ~45º = velocidade máxima
      const vy = (tiltY / 45) * maxSpeed;

      // Movimento com resolução de colisão separada X/Y
      // Movimento em X
      let oldX = player.x;
      player.x += vx * dt;

      for (const wall of walls) {
        if (circleRectCollision(player.x, player.y, player.r, wall)) {
          player.x = oldX; // anula movimento em X
          break;
        }
      }

      // Movimento em Y
      let oldY = player.y;
      player.y += vy * dt;

      for (const wall of walls) {
        if (circleRectCollision(player.x, player.y, player.r, wall)) {
          player.y = oldY; // anula movimento em Y
          break;
        }
      }

      // Limites (só para garantir)
      if (player.x - player.r < 0) player.x = player.r;
      if (player.x + player.r > canvas.width) player.x = canvas.width - player.r;
      if (player.y - player.r < 0) player.y = player.r;
      if (player.y + player.r > canvas.height) player.y = canvas.height - player.r;

      // Verificar recolha de moedas
      let collectedCount = 0;
      for (const c of coins) {
        if (!c.collected) {
          const dx = player.x - c.x;
          const dy = player.y - c.y;
          const dist2 = dx * dx + dy * dy;
          if (dist2 < (player.r + c.r) * (player.r + c.r)) {
            c.collected = true;
          }
        }
        if (c.collected) collectedCount++;
      }

      statusEl.textContent = `Moedas apanhadas: ${collectedCount}/3`;

      // Ativar porta
      if (collectedCount === coins.length) {
        exitDoor.active = true;
      }

      // Verificar se jogador chegou à porta
      if (exitDoor.active) {
        const inDoorX = (player.x + player.r > exitDoor.x) &&
                        (player.x - player.r < exitDoor.x + exitDoor.w);
        const inDoorY = (player.y + player.r > exitDoor.y) &&
                        (player.y - player.r < exitDoor.y + exitDoor.h);
        if (inDoorX && inDoorY) {
          alert("Parabéns! Saíste do labirinto! O jogo vai recomeçar.");
          resetGame();
        }
      }
    }

    // Desenhar
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Fundo
      ctx.fillStyle = "#222";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Paredes
      ctx.fillStyle = "#555";
      walls.forEach(w => {
        ctx.fillRect(w.x, w.y, w.w, w.h);
      });

      // Moedas
      coins.forEach(c => {
        if (!c.collected) {
          ctx.beginPath();
          ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
          ctx.fillStyle = "gold";
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = "#b8860b";
          ctx.stroke();
        }
      });

      // Porta
      if (exitDoor.active) {
        ctx.fillStyle = "#2ecc71";
      } else {
        ctx.fillStyle = "#555";
      }
      ctx.fillRect(exitDoor.x, exitDoor.y, exitDoor.w, exitDoor.h);
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.strokeRect(exitDoor.x, exitDoor.y, exitDoor.w, exitDoor.h);

      // Jogador
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
      ctx.fillStyle = "#0a84ff";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#003366";
      ctx.stroke();
    }

    // Loop
    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 16.67; // ~ normalizar para 60fps
      lastTime = timestamp;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
